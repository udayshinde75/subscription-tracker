import { R as RouteFunction, W as WorkflowServeOptions, E as ExclusiveValidationOptions, T as Telemetry, S as StepType, a as RawStep, N as NotifyResponse, b as Waiter, c as Step } from './types-D1W0VOpy.mjs';
export { A as AsyncStepFunction, C as CallResponse, r as CallSettings, D as Duration, l as FailureFunctionPayload, F as FinishCondition, H as HeaderParams, t as InvokableWorkflow, s as InvokeStepResponse, I as InvokeWorkflowRequest, L as LazyInvokeStepParams, u as LogLevel, p as NotifyStepResponse, P as ParallelCallState, k as PublicServeOptions, m as RequiredExceptFields, j as StepFunction, h as StepTypes, i as SyncStepFunction, q as WaitEventOptions, n as WaitRequest, o as WaitStepResponse, f as WorkflowClient, e as WorkflowContext, w as WorkflowLogger, v as WorkflowLoggerOptions, g as WorkflowReceiver, d as WorkflowTool } from './types-D1W0VOpy.mjs';
import { HTTPMethods, State, FlowControl, Client as Client$1, QstashError } from '@upstash/qstash';
import 'zod';
import 'ai';
import '@ai-sdk/openai';

/**
 * Creates an async method that handles incoming requests and runs the provided
 * route function as a workflow.
 *
 * Not exported in the package. Instead, used in framework specific serve implementations.
 *
 * Only difference from regular serve is the `useJSONContent` parameter.
 *
 * @param routeFunction - A function that uses WorkflowContext as a parameter and runs a workflow.
 * @param options - Options including the client, onFinish callback, and initialPayloadParser.
 * @returns An async method that consumes incoming requests and runs the workflow.
 */
declare const serveBase: <TInitialPayload = unknown, TRequest extends Request = Request, TResponse extends Response = Response, TResult = unknown>(routeFunction: RouteFunction<TInitialPayload, TResult>, telemetry?: Telemetry, options?: WorkflowServeOptions<TResponse, TInitialPayload>) => {
    handler: (request: TRequest) => Promise<TResponse>;
};
/**
 * Creates an async method that handles incoming requests and runs the provided
 * route function as a workflow.
 *
 * @param routeFunction - A function that uses WorkflowContext as a parameter and runs a workflow.
 * @param options - Options including the client, onFinish callback, and initialPayloadParser.
 * @returns An async method that consumes incoming requests and runs the workflow.
 */
declare const serve: <TInitialPayload = unknown, TRequest extends Request = Request, TResponse extends Response = Response, TResult = unknown>(routeFunction: RouteFunction<TInitialPayload, TResult>, options?: Omit<WorkflowServeOptions<TResponse, TInitialPayload>, "useJSONContent" | "schema" | "initialPayloadParser"> & ExclusiveValidationOptions<TInitialPayload>) => ReturnType<typeof serveBase<TInitialPayload, TRequest, TResponse, TResult>>;

type BaseStepLog = {
    /**
     * id of the step
     */
    stepId?: number;
    /**
     * name of the step
     */
    stepName: string;
    /**
     * type of the step (example: "call", "wait", "invoke")
     */
    stepType: StepType;
    /**
     * call type of the step.
     *
     * in most cases it's `step`. For context.call, it will become `toCallback` and `fromCallback`
     * as the step executes.
     */
    callType: RawStep["callType"];
    /**
     * message id of the step
     */
    messageId: string;
    /**
     * result of the step
     *
     * will be undefined for an unfinished parallel step.
     */
    out: unknown;
    /**
     * number of parallel steps
     *
     * if the step is sequential (non-parallel), will be 1.
     */
    concurrent: number;
    /**
     * state of the step
     */
    state: "STEP_PROGRESS" | "STEP_SUCCESS" | "STEP_RETRY" | "STEP_FAILED";
    /**
     * time when the step was created
     */
    createdAt: number;
    /**
     * headers
     */
    headers: Record<string, string[]>;
};
type CallUrlGroup = {
    /**
     * URL called in context.call
     */
    callUrl: string;
    /**
     * Method used in context.call
     */
    callMethod: HTTPMethods;
    /**
     * headers sent in context.call
     */
    callHeaders: Record<string, string[]>;
    /**
     * Body sent in context.call
     */
    callBody: unknown;
};
type CallResponseStatusGroup = {
    /**
     * Status code of the context.call response
     */
    callResponseStatus: number;
    /**
     * Response body of the context.call response
     */
    callResponseBody: unknown;
    /**
     * Headers received from the context.call response
     */
    callResponseHeaders: Record<string, string[]>;
} & CallUrlGroup;
type InvokedWorkflowGroup = {
    /**
     * id of the workflow run invoked in context.invoke
     */
    invokedWorkflowRunId: string;
    /**
     * URL of the workflow invoked in context.invoke
     */
    invokedWorkflowUrl: string;
    /**
     * Time when the workflow was invoked
     */
    invokedWorkflowCreatedAt: number;
    /**
     * Body sent in context.invoke
     */
    invokedWorkflowRunBody: unknown;
    /**
     * Headers sent in context.invoke
     */
    invokedWorkflowRunHeaders: Record<string, string[]>;
};
type WaitEventGroup = {
    /**
     * id of the event waited in context.waitForEvent
     */
    waitEventId: string;
    /**
     * Duration until the time when the event will be triggered due to timeout
     */
    waitTimeoutDuration: string;
    /**
     * Time when the event will be triggered due to timeout
     */
    waitTimeoutDeadline: number;
    /**
     * Whether the event was triggered due to timeout
     */
    waitTimeout: boolean;
};
type AsOptional<TType> = TType | {
    [P in keyof TType]?: never;
};
type StepLog = BaseStepLog & AsOptional<CallUrlGroup> & AsOptional<CallResponseStatusGroup> & AsOptional<InvokedWorkflowGroup> & AsOptional<{
    sleepFor: number;
}> & AsOptional<{
    sleepUntil: number;
}> & AsOptional<WaitEventGroup>;
type StepLogGroup = {
    /**
     * Log which belongs to a single step
     */
    steps: [StepLog];
    /**
     * Log which belongs to a single step
     */
    type: "sequential";
} | {
    /**
     * Log which belongs to parallel steps
     */
    steps: StepLog[];
    /**
     * Log which belongs to parallel steps
     */
    type: "parallel";
} | {
    /**
     * Log which belongs to the next step
     */
    steps: {
        messageId: string;
        state: "STEP_PROGRESS" | "STEP_RETRY" | "STEP_FAILED" | "STEP_CANCELED";
    }[];
    /**
     * Log which belongs to the next step
     */
    type: "next";
};
type FailureFunctionLog = {
    /**
     * messageId of the message published for handling the failure
     */
    messageId: string;
    /**
     * URL of the function that handles the failure
     */
    url: string;
    /**
     * State of the message published for failure
     */
    state: State;
    /**
     * Headers received from the step which caused the workflow to fail
     */
    failHeaders: Record<string, string[]>;
    /**
     * Status code of the step which caused the workflow to fail
     */
    failStatus: number;
    /**
     * Response body of the step which caused the workflow to fail
     */
    failResponse: string;
    dlqId: string;
};
type WorkflowRunLog = {
    /**
     * Unique identifier for the workflow run
     */
    workflowRunId: string;
    /**
     * URL of the workflow that was run
     */
    workflowUrl: string;
    /**
     * State of the workflow run
     *
     * - RUN_STARTED: Workflow run has started and is in progress
     * - RUN_SUCCESS: Workflow run has completed successfully
     * - RUN_FAILED: Workflow run has failed
     */
    workflowState: "RUN_STARTED" | "RUN_SUCCESS" | "RUN_FAILED" | "RUN_CANCELED";
    /**
     * Time when the workflow run was created
     *
     * in unix milliseconds format
     */
    workflowRunCreatedAt: number;
    /**
     * Time when the workflow run was completed
     *
     * in unix milliseconds format
     */
    workflowRunCompletedAt?: number;
    /**
     * Message published when the workflow fails if failureUrl or failureFunction
     * are set.
     */
    failureFunction?: FailureFunctionLog;
    /**
     *
     */
    steps: StepLogGroup[];
    /**
     * If the workflow returned a response, the stringified state of this
     * response will be available in the workflowRunResponse field.
     *
     * To restore it to its original format, use JSON.parse.
     */
    workflowRunResponse?: string;
    /**
     * Information on the invoker workflow run, if any
     */
    invoker?: {
        /**
         * run id of the invoker workflow
         */
        workflowRunId: string;
        /**
         * URL of the invoker workflow
         */
        workflowUrl: string;
        /**
         * Time when the invoker workflow run was created
         *
         * in unix milliseconds format
         */
        workflowRunCreatedAt: number;
    };
};
type WorkflowRunLogs = {
    cursor: string;
    runs: WorkflowRunLog[];
};

type ClientConfig = ConstructorParameters<typeof Client$1>[0];
/**
 * Workflow client for canceling & notifying workflows and getting waiters of an
 * event.
 *
 * ```ts
 * import { Client } from "@upstash/workflow";
 * const client = new Client({ token: "<QSTASH_TOKEN>" })
 * ```
 */
declare class Client {
    private client;
    constructor(clientConfig: ClientConfig);
    /**
     * Cancel an ongoing workflow
     *
     * Returns true if workflow is canceled succesfully. Otherwise, throws error.
     *
     * There are multiple ways you can cancel workflows:
     * - pass one or more workflow run ids to cancel them
     * - pass a workflow url to cancel all runs starting with this url
     * - cancel all pending or active workflow runs
     *
     * ### Cancel a set of workflow runs
     *
     * ```ts
     * // cancel a single workflow
     * await client.cancel({ ids: "<WORKFLOW_RUN_ID>" })
     *
     * // cancel a set of workflow runs
     * await client.cancel({ ids: [
     *   "<WORKFLOW_RUN_ID_1>",
     *   "<WORKFLOW_RUN_ID_2>",
     * ]})
     * ```
     *
     * ### Cancel workflows starting with a url
     *
     * If you have an endpoint called `https://your-endpoint.com` and you
     * want to cancel all workflow runs on it, you can use `urlStartingWith`.
     *
     * Note that this will cancel workflows in all endpoints under
     * `https://your-endpoint.com`.
     *
     * ```ts
     * await client.cancel({ urlStartingWith: "https://your-endpoint.com" })
     * ```
     *
     * ### Cancel *all* workflows
     *
     * To cancel all pending and currently running workflows, you can
     * do it like this:
     *
     * ```ts
     * await client.cancel({ all: true })
     * ```
     *
     * @param ids run id of the workflow to delete
     * @param urlStartingWith cancel workflows starting with this url. Will be ignored
     *   if `ids` parameter is set.
     * @param all set to true in order to cancel all workflows. Will be ignored
     *   if `ids` or `urlStartingWith` parameters are set.
     * @returns true if workflow is succesfully deleted. Otherwise throws QStashError
     */
    cancel({ ids, urlStartingWith, all, }: {
        ids?: string | string[];
        urlStartingWith?: string;
        all?: true;
    }): Promise<{
        cancelled: number;
    } & {
        error?: string;
    }>;
    /**
     * Notify a workflow run waiting for an event
     *
     * ```ts
     * import { Client } from "@upstash/workflow";
     *
     * const client = new Client({ token: "<QSTASH_TOKEN>" })
     * await client.notify({
     *   eventId: "my-event-id",
     *   eventData: "my-data" // data passed to the workflow run
     * });
     * ```
     *
     * @param eventId event id to notify
     * @param eventData data to provide to the workflow
     */
    notify({ eventId, eventData, }: {
        eventId: string;
        eventData?: unknown;
    }): Promise<NotifyResponse[]>;
    /**
     * Check waiters of an event
     *
     * ```ts
     * import { Client } from "@upstash/workflow";
     *
     * const client = new Client({ token: "<QSTASH_TOKEN>" })
     * const result = await client.getWaiters({
     *   eventId: "my-event-id"
     * })
     * ```
     *
     * @param eventId event id to check
     */
    getWaiters({ eventId }: {
        eventId: string;
    }): Promise<Required<Waiter>[]>;
    /**
     * Trigger new workflow run and returns the workflow run id
     *
     * ```ts
     * const { workflowRunId } = await client.trigger({
     *   url: "https://workflow-endpoint.com",
     *   body: "hello there!",         // Optional body
     *   headers: { ... },             // Optional headers
     *   workflowRunId: "my-workflow", // Optional workflow run ID
     *   retries: 3                    // Optional retries for the initial request
     * });
     *
     * console.log(workflowRunId)
     * // wfr_my-workflow
     * ```
     *
     * @param url URL of the workflow
     * @param body body to start the workflow with
     * @param headers headers to use in the request
     * @param workflowRunId optional workflow run id to use. mind that
     *   you should pass different workflow run ids for different runs.
     *   The final workflowRunId will be `wfr_${workflowRunId}`, in
     *   other words: the workflow run id you pass will be prefixed
     *   with `wfr_`.
     * @param retries retry to use in the initial request. in the rest of
     *   the workflow, `retries` option of the `serve` will be used.
     * @returns workflow run id
     */
    trigger({ url, body, headers, workflowRunId, retries, flowControl, }: {
        url: string;
        body?: unknown;
        headers?: Record<string, string>;
        workflowRunId?: string;
        retries?: number;
        flowControl?: FlowControl;
    }): Promise<{
        workflowRunId: string;
    }>;
    /**
     * Fetches logs for workflow runs.
     *
     * @param workflowRunId - The ID of the workflow run to fetch logs for.
     * @param cursor - The cursor for pagination.
     * @param count - Number of runs to fetch. Default value is 10.
     * @param state - The state of the workflow run.
     * @param workflowUrl - The URL of the workflow. Should be an exact match.
     * @param workflowCreatedAt - The creation time of the workflow. If you have two workflow runs with the same URL, you can use this to filter them.
     * @returns A promise that resolves to either a `WorkflowRunLog` or a `WorkflowRunResponse`.
     *
     * @example
     * Fetch logs for a specific workflow run:
     * ```typescript
     * const { runs } = await client.logs({ workflowRunId: '12345' });
     * const steps = runs[0].steps; // access steps
     * ```
     *
     * @example
     * Fetch logs with pagination:
     * ```typescript
     * const { runs, cursor } = await client.logs();
     * const steps = runs[0].steps // access steps
     *
     * const { runs: nextRuns, cursor: nextCursor } = await client.logs({ cursor, count: 2 });
     * ```
     */
    logs(params?: {
        workflowRunId?: WorkflowRunLog["workflowRunId"];
        cursor?: string;
        count?: number;
        state?: WorkflowRunLog["workflowState"];
        workflowUrl?: WorkflowRunLog["workflowUrl"];
        workflowCreatedAt?: WorkflowRunLog["workflowRunCreatedAt"];
    }): Promise<WorkflowRunLogs>;
}

/**
 * Error raised during Workflow execution
 */
declare class WorkflowError extends QstashError {
    constructor(message: string);
}
/**
 * Raised when the workflow executes a function successfully
 * and aborts to end the execution
 */
declare class WorkflowAbort extends Error {
    stepInfo?: Step;
    stepName: string;
    /**
     * whether workflow is to be canceled on abort
     */
    cancelWorkflow: boolean;
    /**
     *
     * @param stepName name of the aborting step
     * @param stepInfo step information
     * @param cancelWorkflow
     */
    constructor(stepName: string, stepInfo?: Step, cancelWorkflow?: boolean);
}

export { Client, ExclusiveValidationOptions, NotifyResponse, RawStep, RouteFunction, Step, type StepLog, StepType, Telemetry, Waiter, WorkflowAbort, WorkflowError, type WorkflowRunLog, type WorkflowRunLogs, WorkflowServeOptions, serve };
